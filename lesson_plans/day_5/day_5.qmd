---
title: "Day 5"
author: "RichÃ¨l Bilderbeek"
format: revealjs
bibliography: day_5.bib
from: markdown+emoji
csl: vancouver.csl
jupyter: python3
css: styles.css
slide-number: true
number-sections: true
---

# Big Picture

## Breaks

Please take breaks:
these are important for learning.
Ideally, do something boring @newport2016deep!

## Break schedule

 * 10:00-10:15
 * 11:00-11:15
 * 12:00-13:00
 * 14:00-14:15
 * 15:00-15:15
 * 16:00-16:15

## Problem

Imagine you have to write code to extract DNA sequences
from a file.
To do so, you need a function to detect if a string is a
DNA sequence.

How would you do that?

## Things we must agree on

```{python}
#| eval: false
#| echo: true
# Strings that are correct
# "A"
# "ACGT"
# Strings that are incorrect
# ""
# "acgt"
# "nonsense"
```

## Pseudocode of the answer

```{python}
#| eval: false
#| echo: true

# Define my function: is_dna_sequence
#  (assume input is a string)
#  if string is empty, return False
#  count the length of the string
#  count the number of As, Cs, Gs, Ts
#  if the ACGT counts add up 
#  to the total length:
#    return True
#  else return False
```

## Can we do better?

Yes, we can! 

We use regular expressions!

## Wikipedia definition

> A regular expression (shortened as regex or regexp)
> is a sequence of characters that specifies a match pattern in text.
>
> Adapted from [Wikipedia](https://en.wikipedia.org/wiki/Regular_expression)

## Q: regex quiz

Do [https://regexone.com](https://regexone.com) lessons 1 to and including 10.

 * Extra: also complete the rest of the tutorial

## Recap

It is a small language on its own indeed!




## Importing the `re` module

To use regexes in Python, 
put this line at the top of your script:

```{python}
#| eval: true
#| echo: true
import re
```

 * Tip: [The Python 're' documentation](https://docs.python.org/3/library/re.html)

## Creating the pattern

A DNA sequence contains only 'A', 'C', 'G' and 'T's
and has at least 1 one of these characters.

This would be the pattern:

```{python}
#| eval: false
#| echo: true
"[ACGT]+"
```

 * `[ACGT]`: must be among these characters
 * `+` ... at least once

## Compiling regexes

```{python}
#| eval: true
#| echo: true
dna_seq_pattern = re.compile("[ACGT]+")
print(dna_seq_pattern)
```

:sunglasses::+1: This results in a finite state machine 
with all `if` statements needed

## Getting a match

```{python}
#| eval: true
#| echo: true
print(dna_seq_pattern.match("A"))
```

:monocle_face:

```{python}
#| eval: true
#| echo: true
print(dna_seq_pattern.match("AACGCGT"))
```

:nerd_face:

```{python}
#| eval: true
#| echo: true
print(dna_seq_pattern.match("nonsense"))
```

:neutral_face:

## Getting a match

```{python}
#| eval: true
#| echo: true
m = dna_seq_pattern.match("ACGT")
if m:
  print("This was a match!")
else:
  print("Nope, no DNA here :-(")
```

## Getting no match

```{python}
#| eval: true
#| echo: true
m = dna_seq_pattern.match("nonsense")
if m:
  print("This was a match!")
else:
  print("Nope, no DNA here :-(")
```

## Q: `is_chess_square` 1/2

![https://en.wikipedia.org/wiki/File:SCD_algebraic_notation.svg](SCD_algebraic_notation.png)

## Q: `is_chess_square` 2/2

Write the pattern to detect if a string is a chess square. Test that it works

![](SCD_algebraic_notation.png)

## A: `is_chess_square` 1/3

```{python}
#| eval: true
#| echo: true
chess_square_pattern = \
  re.compile("[a-h][1-8]")
```

 * The first character is `a`, `b` `c`, etc. to and including `h`
 * The second character is `1`, `2` `3`, etc. to and including `8`
 * :monocle_face: Can you spot the mistake already?

## A: `is_chess_square` 2/3

```{python}
#| eval: true
#| echo: true
m = chess_square_pattern.match("d5")
if m:
  print("This was a match!")
else:
  print("Nope, no chess square here :-(")
```

## A: `is_chess_square` 1/3

```{python}
#| eval: true
#| echo: true
m = chess_square_pattern.match("ACGT")
if m:
  print("This was a match!")
else:
  print("Nope, no chess square here :-(")
```

## Putting `is_chess_square` in a function

```{python}
#| eval: true
#| echo: true
def is_chess_square(s):
  p = re.compile("[a-h][1-8]")
  return chess_square_pattern.match(s)
```

## Using `is_chess_square`

```{python}
#| eval: true
#| echo: true
print(is_chess_square("a1"))
```

:nerd_face:

```{python}
#| eval: true
#| echo: true
print(is_chess_square("nonsense"))
```

:monocle_face:

## Testing `is_chess_square`

```{python}
#| eval: true
#| echo: true
assert is_chess_square("a1")
assert not is_chess_square("nonsense")
```

## Q: `is_chess_square` in your code

Put the `is_chess_square` function and tests in your code.

Confirm that everything works as expected on your computer!

Bonus: the pattern is imperfect. Can you find an example?

## Unexpected `is_chess_square`

```{python}
#| eval: true
#| echo: true
if is_chess_square("a123"):
  print("This is unexpected!")
```

## Problem `is_chess_square`

 * The first character is `a`, `b` `c`, etc. to and including `h`
 * The second character is `1`, `2` `3`, etc. to and including `8`
 * **A chess square has two characters**

## Q: Fix `is_chess_square`

Fix `is_chess_square`. 

Use [the Python 're' documentation](https://docs.python.org/3/library/re.html)

 * Tip: [see the search versus match section](https://docs.python.org/3/library/re.html#search-vs-match)

## A: Fix `is_chess_square`

```{python}
#| eval: true
#| echo: true
def is_chess_square(s):
  p = re.compile("[a-h][1-8]")
  return p.fullmatch(s)
```

 * Use `fullmatch`, instead of `search` or `match`
 * `search` and `"^[a-h][1-8]$"` fails???
 
## Print that `is_chess_square` works

```{python}
#| eval: true
#| echo: true
print(is_chess_square("a1234"))
```

:sunglasses::+1:

```{python}
#| eval: true
#| echo: true
if is_chess_square("a1234"):
  print("WEIRD!")
else:
  print("Life is good!")
```

## Testing `is_chess_square`

```{python}
#| eval: true
#| echo: true
assert is_chess_square("a1")
assert not is_chess_square("a1234")
assert not is_chess_square("nonsense")
```

## Q: regex for first name in English?

In English: what is the regular expression for a first name?

## A: first name

A first name:

 * start with a capital letter
 * then has lowercase characters only
 * :monocle_face: do you already spot the flaw?

## Q: program the regex for first name

 * [Python doc: Regular expression HOWTO](https://docs.python.org/3/howto/regex.html)
 * [The 're' documentation](https://docs.python.org/3/library/re.html)


How to do better?

:woman_technologist: Write down in the HackMD! :man_technologist:



## Questions about today's theory?

:woman_technologist: Write down in the HackMD! :man_technologist:

# Done!

Go home and rest :-)

# Breaks

Are important. Please rest!

## Break 1: 10:00-10:15



## Break 2: 11:00-11:15



## Break 3: 12:00-13:00



## Break 4: 14:00-14:15



## Break 5: 15:00-15:15



## Break 6: 16:00-16:15



## Done



## References
